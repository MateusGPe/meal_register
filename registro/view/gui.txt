# ----------------------------------------------------------------------------
# File: registro/view/gui.py (Main View/Application - Final Reviewed Version)
# ----------------------------------------------------------------------------
# SPDX-License-Identifier: MIT
# Copyright (c) 2024-2025 Mateus G Pereira <mateus.pereira@ifsp.edu.br>

"""
Provides the main application class (`RegistrationApp`) for the meal registration
system, managing the GUI, session lifecycle, and coordinating MVC interactions.
Features a redesigned single-view layout with panes, uses a SimpleTreeView
wrapper for tables, includes row-specific delete buttons, and debounced search.
"""
import ctypes
import json
import logging
import platform
import re
import sys
import tkinter as tk
from datetime import datetime
from functools import partial
from pathlib import Path
from threading import Thread
from tkinter import TclError, messagebox
from typing import Any, Dict, List, Optional, Set, Tuple, Union

import ttkbootstrap as ttk
from fuzzywuzzy import fuzz
from ttkbootstrap.constants import *

# Local Application Components
from registro.control.constants import (PRONTUARIO_CLEANUP_REGEX, SESSION_PATH,
                                        SNACKS_JSON_PATH, NewSessionData)
from registro.control.excel_exporter import export_to_excel
from registro.control.session_manage import SessionManager
from registro.control.sync_thread import SpreadsheetThread, SyncReserves
from registro.control.utils import \
    capitalize  # Removed to_code as it's not used directly here
# Dialogs
from registro.view.class_filter_dialog import ClassFilterDialog
from registro.view.session_dialog import SessionDialog

# Removed direct Tableview import, using SimpleTreeView wrapper below
# from ttkbootstrap.tableview import Tableview


logger = logging.getLogger(__name__)


# --- Simple TreeView Wrapper ---
class SimpleTreeView:
    """ A simple wrapper around ttk.Treeview for basic table display functionalities. """

    def __init__(self, master: tk.Widget, coldata: List[Dict[str, Any]], height: int = 10, bootstyle=PRIMARY):
        self.master = master
        self.coldata = coldata
        # Generate unique internal column IDs based on 'iid' if provided, otherwise use text as fallback
        # Ensure these IDs are valid for Tkinter (usually simple strings without problematic chars)
        self.column_ids = []
        for i, cd in enumerate(coldata):
            iid = cd.get('iid')
            text = cd.get('text', f'col_{i}')
            # Basic sanitization for fallback ID if text has tricky characters
            fallback_id = re.sub(r'\W|^(?=\d)', '_', text) if not iid else iid
            self.column_ids.append(iid if iid else fallback_id)
        logger.debug(f"SimpleTreeView column IDs: {self.column_ids}")

        self.frame = ttk.Frame(master)
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)

        # --- Treeview ---
        self.view = ttk.Treeview(
            self.frame,
            columns=self.column_ids,  # Use generated IDs
            show='headings',
            height=height,
            selectmode='browse',
            bootstyle=bootstyle
        )
        self.view.grid(row=0, column=0, sticky='nsew')

        # --- Scrollbars ---
        sb_v = ttk.Scrollbar(self.frame, orient=VERTICAL, command=self.view.yview)
        sb_v.grid(row=0, column=1, sticky='ns')
        sb_h = ttk.Scrollbar(self.frame, orient=HORIZONTAL, command=self.view.xview)
        sb_h.grid(row=1, column=0, sticky='ew')
        self.view.configure(yscrollcommand=sb_v.set, xscrollcommand=sb_h.set)

        # --- Configure Columns ---
        for i, cd in enumerate(self.coldata):
            col_id = self.column_ids[i]  # Use the determined column ID
            width = cd.get('width', 100)
            stretch = cd.get('stretch', False)
            anchor = cd.get('anchor', W)
            text = cd.get('text', col_id)  # Display text from coldata
            try:
                self.view.column(col_id, width=width, stretch=stretch, anchor=anchor)
                self.view.heading(col_id, text=text, anchor=anchor)
            except tk.TclError as e:
                logger.error(f"Error configuring treeview column '{col_id}' with text '{text}': {e}")

    def grid(self, **kwargs):
        """ Pass grid options to the main frame. """
        self.frame.grid(**kwargs)

    def pack(self, **kwargs):
        """ Pass pack options to the main frame. """
        self.frame.pack(**kwargs)

    def delete_rows(self, iids: Optional[List[str]] = None):
        """ Deletes specified rows (by iid) or all rows if iids is None. """
        target_iids = iids if iids is not None else self.view.get_children()
        if not target_iids:
            return  # Nothing to delete
        try:
            self.view.delete(*target_iids)  # Unpack argument list
        except tk.TclError as e:
            logger.error(f"Error deleting rows {target_iids}: {e}")

    def build_table_data(self, coldata: List[Dict[str, Any]], rowdata: List[Tuple]):
        """ Clears and rebuilds the table with new data using auto-generated iids. """
        self.delete_rows()
        # Note: Does not handle coldata changes after init for simplicity
        for row_values in rowdata:
            try:
                if len(row_values) == len(self.column_ids):
                    self.view.insert('', END, values=row_values)  # Let treeview generate iid
                else:
                    logger.warning(
                        f"Row data length mismatch: {len(row_values)} values, {len(self.column_ids)} columns. Row: {row_values}")
            except Exception as e:
                logger.error(f"Error inserting row data {row_values}: {e}")

    def insert_row(self, values: Tuple, index: Union[int, str] = END, iid: Optional[str] = None) -> Optional[str]:
        """ Inserts a single row, optionally with a specific iid. Returns the iid used. """
        try:
            # If iid is not provided, Treeview generates one. We return it.
            actual_iid = self.view.insert('', index, values=values, iid=iid)
            return actual_iid
        except tk.TclError as e:
            logger.error(f"Error inserting row {values} with iid {iid}: {e}")
            return None

    def get_children_iids(self) -> Tuple[str, ...]:
        """ Returns a tuple of all item IDs currently in the treeview. """
        try:
            return self.view.get_children()
        except tk.TclError as e:
            logger.error(f"Error getting children iids: {e}")
            return tuple()

    def get_selected_iid(self) -> Optional[str]:
        """ Returns the iid of the first selected item, or None. """
        selection = self.view.selection()
        return selection[0] if selection else None

    def get_row_values(self, iid: str) -> Optional[Tuple]:
        """ Gets the tuple of values for a given item ID based on column order. """
        if self.view.exists(iid):
            try:
                item_dict = self.view.set(iid)  # Gets {col_id: value}
                # Ensure values are returned in the original column order
                return tuple(item_dict.get(col_id, '') for col_id in self.column_ids)
            except (tk.TclError, KeyError) as e:
                logger.error(f"Error getting values for iid {iid}: {e}")
                return None
        return None

    def get_selected_row_values(self) -> Optional[Tuple]:
        """ Gets the tuple of values for the currently selected row. """
        selected_iid = self.get_selected_iid()
        return self.get_row_values(selected_iid) if selected_iid else None


# --- Main Application Class ---
class RegistrationApp(tk.Tk):
    """ Main application window (Redesigned UI + Debounce + SimpleTreeView). """

    SEARCH_DEBOUNCE_DELAY = 350  # Milliseconds

    def __init__(self, title: str = "RU IFSP - Meal Registration"):
        super().__init__()
        self.title(title)
        self.protocol("WM_DELETE_WINDOW", self.on_close_app)

        self._configure_style()
        self._configure_grid_layout_new()

        # Internal state
        self._selected_eligible_data: Optional[Dict[str, Any]] = None
        self._current_eligible_matches_data: List[Dict[str, Any]] = []
        self._search_after_id: Optional[str] = None
        self._row_delete_buttons: Dict[str, ttk.Button] = {}  # Maps registered row iid -> delete button

        # UI Element Attributes (initialized to None for safety)
        # These will be assigned in the _create_* methods
        self._status_bar_label: Optional[ttk.Label] = None
        self._progress_bar: Optional[ttk.Progressbar] = None
        self._session_info_label: Optional[ttk.Label] = None
        self._main_paned_window: Optional[ttk.PanedWindow] = None
        self._action_panel: Optional[ttk.Frame] = None
        self._status_panel: Optional[ttk.Frame] = None
        self._search_entry_var: Optional[tk.StringVar] = None
        self._search_entry: Optional[ttk.Entry] = None
        self._eligible_students_tree: Optional[SimpleTreeView] = None
        self._selected_student_label: Optional[ttk.Label] = None
        self._register_button: Optional[ttk.Button] = None
        self._action_feedback_label: Optional[ttk.Label] = None
        self._registered_count_label: Optional[ttk.Label] = None
        self._remaining_count_label: Optional[ttk.Label] = None
        self._registered_students_table: Optional[SimpleTreeView] = None
        self._delete_button_frame: Optional[ttk.Frame] = None  # Frame holding delete buttons

        try:
            self._session_manager = SessionManager()
        except Exception as e:
            self._handle_initialization_error("Session Manager", e)
            return

        try:
            self._create_top_bar()
            self._main_paned_window = self._create_main_panels()
            self._create_status_bar()
        except Exception as e:
            self._handle_initialization_error("UI Construction", e)
            return

        self._load_initial_session()

    # --- Initialization and Configuration ---
    def _handle_initialization_error(self, component: str, error: Exception):
        """ Displays critical error and exits. """
        logger.critical(f"Critical error initializing {component}: {error}", exc_info=True)
        try:
            messagebox.showerror("Init Error", f"Failed: {component}\n{error}\n\nApp closing.")
        except Exception:
            print(f"CRITICAL ERROR: {component}: {error}", file=sys.stderr)
        try:
            self.destroy()
        except tk.TclError:
            pass
        sys.exit(1)

    def _configure_style(self):
        """ Configures ttkbootstrap theme and styles. """
        try:
            self.style = ttk.Style(theme='litera')
            self.style.configure('Treeview', rowheight=28, font=('Segoe UI', 10))
            self.style.configure('Treeview.Heading', font=('Segoe UI', 10, 'bold'))
            self.style.configure('TLabelframe.Label', font=('Segoe UI', 11, 'bold'))
            # Style for delete buttons
            self.style.configure('DangerLink.TButton', foreground=self.style.colors.danger,
                                 underline=True, font=('Segoe UI', 10))
            self.colors = self.style.colors
        except (TclError, AttributeError) as e:
            logger.warning(f"Style configuration error: {e}. Using defaults.")
            self.colors = ttk.Style().colors

    def _configure_grid_layout_new(self):
        """ Configures main window grid. """
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=1)
        self.grid_rowconfigure(2, weight=0)
        self.grid_columnconfigure(0, weight=1)

    # --- UI Creation Methods ---
    def _create_top_bar(self):
        """ Creates the top bar with session info and global action buttons. """
        top_bar = ttk.Frame(self, padding=(10, 5), bootstyle=LIGHT)
        top_bar.grid(row=0, column=0, sticky="ew")

        self._session_info_label = ttk.Label(top_bar, text="Loading...", font="-size 14 -weight bold")
        self._session_info_label.pack(side=LEFT, padx=(0, 20))

        buttons_frame = ttk.Frame(top_bar, bootstyle=LIGHT)
        buttons_frame.pack(side=RIGHT)

        ttk.Button(buttons_frame, text="💾 Export & End", command=self.export_and_end_session,
                   bootstyle=DANGER, width=16).pack(side=RIGHT, padx=(10, 0))
        ttk.Button(buttons_frame, text="📤 Sync Served Data", command=self.sync_session_with_spreadsheet,
                   bootstyle="success-outline", width=18).pack(side=RIGHT, padx=3)
        ttk.Button(buttons_frame, text="🔄 Sync Master Data", command=self._sync_master_data,
                   bootstyle="warning-outline", width=18).pack(side=RIGHT, padx=3)
        ttk.Separator(buttons_frame, orient=VERTICAL).pack(side=RIGHT, padx=8, fill='y', pady=3)
        ttk.Button(buttons_frame, text="📊 Filter Classes", command=self._open_class_filter_dialog,
                   bootstyle="info-outline", width=15).pack(side=RIGHT, padx=3)
        ttk.Button(buttons_frame, text="⚙️ Change Session", command=self._open_session_dialog,
                   bootstyle="secondary-outline", width=16).pack(side=RIGHT, padx=3)

    def _create_main_panels(self) -> ttk.PanedWindow:
        """ Creates the main PanedWindow dividing Action and Status panels. """
        main_pane = ttk.PanedWindow(self, orient=HORIZONTAL, bootstyle="light")
        main_pane.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
        self._action_panel = self._create_action_search_panel(main_pane)
        main_pane.add(self._action_panel, weight=1)
        self._status_panel = self._create_status_registered_panel(main_pane)
        main_pane.add(self._status_panel, weight=2)
        return main_pane

    def _create_action_search_panel(self, parent: ttk.PanedWindow) -> ttk.Frame:
        """ Creates the left panel for search, eligible list, preview, register. """
        frame = ttk.Frame(parent, padding=10)
        frame.grid_rowconfigure(1, weight=1)
        frame.grid_columnconfigure(0, weight=1)

        # 1. Search Bar
        search_bar = ttk.Frame(frame)
        search_bar.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        search_bar.grid_columnconfigure(0, weight=1)
        self._search_entry_var = tk.StringVar()
        self._search_entry_var.trace_add("write", self._on_search_entry_change)
        self._search_entry = ttk.Entry(search_bar, textvariable=self._search_entry_var, font=(None, 12), bootstyle=INFO)
        self._search_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5))
        ttk.Button(search_bar, text="❌ Clear", width=8, command=lambda: self._search_entry_var.set(
            ''), bootstyle="danger-outline").grid(row=0, column=1)
        self._search_entry.bind('<Return>', lambda e: self._register_selected_eligible())

        # 2. Eligible Students Treeview
        eligible_frame = ttk.Labelframe(frame, text="🔍 Eligible Students (Search Results)", padding=(5, 5))
        eligible_frame.grid(row=1, column=0, sticky="nsew")
        eligible_frame.grid_rowconfigure(0, weight=1)
        eligible_frame.grid_columnconfigure(0, weight=1)
        cols = [{"text": "Name", "stretch": True, "iid": "name"}, {"text": "Class | Pront", "width": 150,
                                                                   "anchor": W, "iid": "info"}, {"text": "Dish/Status", "width": 120, "anchor": W, "iid": "dish"}]
        self._eligible_students_tree = SimpleTreeView(master=eligible_frame, coldata=cols, bootstyle=PRIMARY, height=10)
        self._eligible_students_tree.grid(row=0, column=0, sticky="nsew")
        self._eligible_students_tree.view.bind("<<TreeviewSelect>>", self._on_eligible_student_select)
        self._eligible_students_tree.view.bind("<Double-1>", lambda e: self._register_selected_eligible())

        # 3. Selection Preview Area
        preview_frame = ttk.Frame(frame, padding=(0, 5))
        preview_frame.grid(row=2, column=0, sticky="ew", pady=(10, 5))
        self._selected_student_label = ttk.Label(
            preview_frame, text="Select a student from the list above.", justify=LEFT, font=('Segoe UI', 9))
        self._selected_student_label.pack(fill=X, expand=True)

        # 4. Register Button and Local Feedback
        action_frame = ttk.Frame(frame)
        action_frame.grid(row=3, column=0, sticky="ew", pady=(5, 0))
        action_frame.columnconfigure(0, weight=1)
        self._register_button = ttk.Button(action_frame, text="➕ Register Selected",
                                           command=self._register_selected_eligible, bootstyle="success", state=DISABLED)
        self._register_button.pack(side=LEFT, fill=X, expand=True, padx=(0, 10))
        self._action_feedback_label = ttk.Label(action_frame, text="", font=('Segoe UI', 9), width=30, anchor=E)
        self._action_feedback_label.pack(side=RIGHT)

        return frame

    def _create_status_registered_panel(self, parent: ttk.PanedWindow) -> ttk.Frame:
        """ Creates the right panel for stats and registered students list with delete buttons. """
        frame = ttk.Frame(parent, padding=10)
        frame.grid_rowconfigure(1, weight=1)
        frame.grid_columnconfigure(0, weight=1)

        # 1. Counters Frame
        counters_frame = ttk.Frame(frame)
        counters_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        self._registered_count_label = ttk.Label(
            counters_frame, text="Registered: -", bootstyle="inverse-primary", padding=5, font=('Segoe UI', 10, 'bold'))
        self._registered_count_label.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)
        self._remaining_count_label = ttk.Label(
            counters_frame, text="Eligible/Remaining: -/-", bootstyle="inverse-success", padding=5, font=('Segoe UI', 10, 'bold'))
        self._remaining_count_label.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)

        # 2. Registered Students Table Frame (holds TreeView + Button Column)
        reg_frame = ttk.Labelframe(frame, text="✅ Registered Students (This Session)", padding=(5, 5))
        reg_frame.grid(row=1, column=0, sticky="nsew")
        reg_frame.rowconfigure(0, weight=1)
        reg_frame.columnconfigure(0, weight=1)
        reg_frame.columnconfigure(1, weight=0)  # Col 1 for buttons

        # Define Columns for the Treeview part
        self.registered_cols_definition = [
            {"text": "🆔 Pront.", "stretch": False, "width": 100, "iid": "pront"},
            {"text": "✍️ Name", "stretch": True, "iid": "nome"},
            {"text": "👥 Class", "stretch": False, "width": 150, "iid": "turma"},
            {"text": "⏱️ Time", "stretch": False, "width": 70, "anchor": tk.CENTER, "iid": "hora"},
            {"text": "🍽️ Dish/Status", "stretch": True, "width": 150, "iid": "prato"}
        ]
        # Create the SimpleTreeView wrapper
        self._registered_students_table = SimpleTreeView(
            master=reg_frame, coldata=self.registered_cols_definition, bootstyle=PRIMARY, height=15)
        self._registered_students_table.grid(row=0, column=0, sticky='nsew')  # Place in column 0

        # Frame specifically for delete buttons, placed next to the treeview
        self._delete_button_frame = ttk.Frame(reg_frame)
        self._delete_button_frame.grid(row=0, column=1, sticky='ns', padx=(2, 0))

        # Enable sorting (uses column iids defined above)
        try:
            actual_column_ids = self._registered_students_table.column_ids
            logger.debug(f"Setting sort commands for registered table columns: {actual_column_ids}")
            for col_id in actual_column_ids:
                self._registered_students_table.view.heading(
                    col_id, command=partial(self._sort_registered_table, col_id, False))
        except Exception as e:
            logger.exception(f"Error setting up registered table sorting: {e}")

        self._registered_students_table.view.bind("<Delete>", self.on_table_delete_key)  # Keep delete key binding

        return frame

    def _sort_registered_table(self, col_id: str, reverse: bool):
        """ Sorts the registered students treeview and repositions delete buttons. """
        if not self._registered_students_table:
            return
        treeview = self._registered_students_table.view
        try:
            data = [(treeview.set(iid, col_id), iid) for iid in treeview.get_children('')]
        except tk.TclError as e:
            logger.error(f"Sort Error (get): {col_id}, {e}")
            return
        try:
            def key_func(t): return t[0].lower() if isinstance(t[0], str) else t[0]
            data.sort(key=key_func, reverse=reverse)
        except Exception as sort_err:
            logger.exception(f"Sort Error (sort): {col_id}, {sort_err}")
            return
        for index, (_, iid) in enumerate(data):
            try:
                treeview.move(iid, '', index)
            except tk.TclError as move_err:
                logger.error(f"Sort Error (move): {iid}, {move_err}")
        self._reorder_delete_buttons()  # Re-grid buttons after sorting treeview
        try:
            treeview.heading(col_id, command=partial(self._sort_registered_table, col_id, not reverse))
        except tk.TclError as head_err:
            logger.error(f"Sort Error (heading): {col_id}, {head_err}")

    def _reorder_delete_buttons(self):
        """ Re-grids delete buttons according to the current Treeview item order. """
        if not self._delete_button_frame or not self._registered_students_table:
            return
        try:
            # Temporarily hide all buttons
            for btn in self._delete_button_frame.winfo_children():
                btn.grid_forget()
            # Get current order of items in the treeview
            ordered_iids = self._registered_students_table.get_children_iids()
            # Re-grid the buttons that still exist in the correct order
            for row_index, iid in enumerate(ordered_iids):
                if iid in self._row_delete_buttons:
                    self._row_delete_buttons[iid].grid(row=row_index, column=0, pady=1, sticky='n')
        except tk.TclError as e:
            logger.error(f"Error reordering delete buttons: {e}")

    def _add_delete_button(self, iid: str, row_index: int):
        """ Adds a delete button for a specific row iid at the correct index. """
        if not self._delete_button_frame or not iid:
            return  # Safety checks
        # If button already exists (e.g., during refresh), ensure it's gridded correctly
        if iid in self._row_delete_buttons:
            try:
                self._row_delete_buttons[iid].grid(row=row_index, column=0, pady=1, sticky='n')
            except tk.TclError as e:
                logger.error(f"Error re-gridding button for {iid}: {e}")
            return

        # Create new button
        button = ttk.Button(
            self._delete_button_frame, text="🗑️", bootstyle="danger-link", width=3,
            command=lambda i=iid: self._delete_row_by_button(i))
        try:
            button.grid(row=row_index, column=0, pady=1, sticky='n')  # Adjust pady for alignment
            self._row_delete_buttons[iid] = button
        except tk.TclError as e:
            logger.error(f"Error gridding new button for {iid}: {e}")
            button.destroy()  # Clean up if gridding failed

    def _remove_delete_button(self, iid: str):
        """ Removes and destroys the delete button associated with a row iid. """
        if iid in self._row_delete_buttons:
            button = self._row_delete_buttons.pop(iid)
            try:
                button.destroy()
            except tk.TclError:
                pass  # Ignore error if already destroyed

    def _clear_all_delete_buttons(self):
        """ Removes all delete buttons from UI and internal map. """
        if not hasattr(self, '_row_delete_buttons'):
            return
        for iid in list(self._row_delete_buttons.keys()):
            self._remove_delete_button(iid)

    def _delete_row_by_button(self, iid_to_delete: str):
        """ Handles deletion when a row's delete button is clicked. """
        logger.debug(f"Delete button clicked for row iid: {iid_to_delete}")
        if not self._registered_students_table:
            return
        row_values = self._registered_students_table.get_row_values(iid_to_delete)
        if not row_values:
            logger.error(f"Could not get data for iid {iid_to_delete} to delete by button.")
            messagebox.showerror("Error", "Cannot find data for selected row.", parent=self)
            self._remove_delete_button(iid_to_delete)  # Clean up inconsistent state
            return
        # Call the common confirmation/deletion logic, passing iid
        self.on_delete_confirmed(row_values, iid_to_delete)

    def _create_status_bar(self):
        """ Creates the bottom status bar. """
        status_bar = ttk.Frame(self, padding=(5, 3), bootstyle=LIGHT, name='statusBarFrame')
        status_bar.grid(row=2, column=0, sticky="ew")
        self._status_bar_label = ttk.Label(status_bar, text="Ready.")
        self._status_bar_label.pack(side=LEFT, padx=5)
        self._progress_bar = ttk.Progressbar(status_bar, mode='indeterminate', bootstyle='striped-info', length=200)
        # Progress bar packed/unpacked by show_progress_bar

    # --- Session Loading and Management ---
    def _load_initial_session(self):
        logger.info("Attempting to load initial session state...")
        session_info = self._session_manager.load_session()
        if session_info:
            logger.info(f"Loaded active session ID: {session_info.get('session_id')}.")
            self._setup_ui_for_loaded_session()
        else:
            logger.info("No active session found. Opening SessionDialog.")
            self.after(100, self._open_session_dialog)

    def handle_session_dialog_result(self, result: Union[NewSessionData, int, None]) -> bool:
        if result is None:
            logger.info("SessionDialog cancelled.")
            if self._session_manager.get_session_info() is None:
                self.on_close_app()
            return True  # Allow dialog close

        success = False
        action_desc = ""
        if isinstance(result, int):
            action_desc = f"load session ID: {result}"
            if self._session_manager.load_session(result):
                success = True
        elif isinstance(result, dict):
            action_desc = f"create new session: {result.get('refeição')} {result.get('data')}"
            if self._session_manager.new_session(result):
                success = True

        if success:
            logger.info(f"Successfully completed: {action_desc}")
            self._setup_ui_for_loaded_session()
            return True
        else:
            logger.error(f"Failed: {action_desc}")
            messagebox.showerror("Op Failed", f"Could not {action_desc}.", parent=self)
            return False

    def _setup_ui_for_loaded_session(self):
        logger.debug("Configuring UI for active session...")
        session_details = self._session_manager.get_session_info()
        ui_elements = {
            'info_label': getattr(self, '_session_info_label', None), 'search': getattr(self, '_search_entry', None),
            'register_btn': getattr(self, '_register_button', None), 'eligible_tbl': getattr(self, '_eligible_students_tree', None),
            'registered_tbl': getattr(self, '_registered_students_table', None)}
        if not session_details:
            logger.error("Cannot setup UI: No session details.")
            self.title("RU Reg [No Session]")
            if ui_elements['info_label']:
                ui_elements['info_label'].config(text="Error: No Active Session")
            if ui_elements['search']:
                ui_elements['search'].config(state=DISABLED)
            if ui_elements['register_btn']:
                ui_elements['register_btn'].config(state=DISABLED)
            if ui_elements['eligible_tbl']:
                ui_elements['eligible_tbl'].delete_rows()
            if ui_elements['registered_tbl']:
                ui_elements['registered_tbl'].delete_rows()
                self._clear_all_delete_buttons()
            return

        session_id, date_str, meal_type_str, _ = session_details
        meal_display = capitalize(meal_type_str or "Unk")
        date_display = date_str or "????"
        time_display = self._session_manager.get_time() or "??"
        title = f"Registro: {meal_display} - {date_display} {time_display} [ID: {session_id}]"
        self.title(title)
        if ui_elements['info_label']:
            ui_elements['info_label'].config(text=title)
        if ui_elements['search']:
            ui_elements['search'].config(state=NORMAL)

        self.load_registered_students_into_table()
        self._refresh_ui_after_data_change()
        self.focus_search_entry()
        self.deiconify()
        self.lift()
        self.focus_force()
        logger.info(f"UI configured for active session ID: {session_id}")

    # --- UI Update Methods ---
    def load_registered_students_into_table(self):
        logger.debug("Loading registered students into SimpleTreeView...")
        if not self._registered_students_table:
            logger.error("Registered table not ready.")
            return
        try:
            self._registered_students_table.delete_rows()
            self._clear_all_delete_buttons()
            served_data = self._session_manager.get_served_students_details()
            if served_data:
                for i, row_values in enumerate(served_data):
                    try:
                        iid = self._registered_students_table.insert_row(values=row_values, index=i)  # Insert in order
                        if iid:
                            self._add_delete_button(iid, i)  # Add button for the new row iid
                    except Exception as insert_err:
                        logger.error(f"Failed inserting row {i}: {row_values}, {insert_err}")
                self._reorder_delete_buttons()  # Ensure alignment after potential errors/reordering
                logger.info(f"Loaded {len(served_data)} registered students.")
            else:
                logger.info("No registered students to display.")
        except Exception as e:
            logger.exception("Error loading registered students table.")
            messagebox.showerror("Table Error", "Could not load registered.", parent=self)

    def update_info_display(self):
        if not hasattr(self, '_registered_count_label') or not hasattr(self, '_remaining_count_label'):
            return
        if self._session_manager is None or self._session_manager.get_session_info() is None:
            self._registered_count_label.config(text="Reg: -")
            self._remaining_count_label.config(text="Elig/Rem: -/-")
            return
        try:
            registered_count = len(self._session_manager.get_served_pronts())
            eligible_students = self._session_manager.get_eligible_students()
            eligible_count = len(eligible_students) if eligible_students is not None else 0
            remaining_count = eligible_count - registered_count
            self._registered_count_label.config(text=f"Reg: {registered_count}")
            self._remaining_count_label.config(text=f"Elig: {eligible_count} / Rem: {remaining_count}")
            # logger.debug(f"Counters updated: Reg={registered_count}, Elig={eligible_count}, Rem={remaining_count}") # Reduce log noise
        except Exception as e:
            logger.exception("Error updating counters.")

    # --- Action Callbacks ---
    def _open_session_dialog(self):
        logger.info("Opening SessionDialog.")
        SessionDialog("Select or Create Session", self.handle_session_dialog_result, self)

    def _open_class_filter_dialog(self):
        if not self._session_manager.get_session_info():
            messagebox.showwarning("No Session", "No active session.", parent=self)
            return
        logger.info("Opening ClassFilterDialog.")
        ClassFilterDialog(self, self._session_manager, self.on_class_filter_apply)

    def on_class_filter_apply(self, selected_identifiers: List[str]):
        logger.info(f"Applying class filters: {selected_identifiers}")
        if self._session_manager.set_session_classes(selected_identifiers) is not None:
            logger.info("Class filters applied.")
            self._refresh_ui_after_data_change()
        else:
            logger.error("Failed to apply filters.")
            messagebox.showerror("Filter Error", "Failed.", parent=self)

    def show_progress_bar(self, start: bool, text: Optional[str] = None):
        # Use safe access with getattr
        progress_bar = getattr(self, '_progress_bar', None)
        status_label = getattr(self, '_status_bar_label', None)
        if not progress_bar or not status_label:
            logger.error("Progress/Status UI elements missing.")
            return
        try:
            if start:
                progress_text = text or "Processing..."
                logger.debug(f"Showing progress: {progress_text}")
                status_label.config(text=progress_text)
                if not progress_bar.winfo_ismapped():
                    progress_bar.pack(side=RIGHT, padx=5, pady=0, fill=X, expand=True)
                    progress_bar.start(10)
            else:
                logger.debug("Hiding progress bar.")
                if progress_bar.winfo_ismapped():
                    progress_bar.stop()
                    progress_bar.pack_forget()
                status_label.config(text="Ready.")
        except tk.TclError as e:
            logger.error(f"Error managing progress bar: {e}")
        except AttributeError as ae:
            logger.error(f"AttributeError progress bar: {ae}.")

    def _sync_master_data(self):
        logger.info("Sync Master Data requested.")
        if not messagebox.askyesno("Confirm", "Sync student/reservation data from Sheets?", parent=self):
            logger.info("Sync cancelled.")
            return
        self.show_progress_bar(True, "Syncing Master Data from Google Sheets...")
        sync_thread = SyncReserves(self._session_manager)
        sync_thread.start()
        self._monitor_sync_thread(sync_thread, "Master Data Sync")

    def _monitor_sync_thread(self, thread: Thread, task_name: str):
        if thread.is_alive():
            self.after(150, lambda: self._monitor_sync_thread(thread, task_name))
            return
        self.show_progress_bar(False)
        error = getattr(thread, 'error', None)
        success = getattr(thread, 'success', False)
        if error:
            logger.error(f"{task_name} fail: {error}", exc_info=isinstance(error, Exception))
            messagebox.showerror(f'Error', f'{task_name} Failed:\n{error}', parent=self)
        elif success:
            logger.info(f"{task_name} success.")
            messagebox.showinfo(f'Complete', f'{task_name} successful.', parent=self)
            self._refresh_ui_after_data_change()
        else:
            logger.warning(f"{task_name} indeterminate state.")
            messagebox.showwarning(f'Unknown', f'{task_name} finished, status unclear.', parent=self)

    def _refresh_ui_after_data_change(self):
        logger.info("Refreshing UI after data change...")
        if not self._session_manager.get_session_info():
            logger.warning("No active session.")
            return
        self._session_manager.filter_eligible_students()
        self._on_search_entry_change()  # Update eligible list based on current search
        self.update_info_display()

    # --- Action Panel Logic (Debounced Search, Select, Register) ---
    def _on_search_entry_change(self, *args):
        if self._search_after_id is not None:
            self.after_cancel(self._search_after_id)
            self._search_after_id = None
        search_term = self._search_entry_var.get() if hasattr(self, '_search_entry_var') else ""
        if len(search_term) < 2:
            if hasattr(self, '_eligible_students_tree'):
                self._eligible_students_tree.delete_rows()
            self._selected_eligible_data = None
            self._current_eligible_matches_data = []
            if hasattr(self, '_register_button'):
                self._register_button.config(state=DISABLED)
            if hasattr(self, '_selected_student_label'):
                self._selected_student_label.config(text="Enter min 2 chars")
            if hasattr(self, '_action_feedback_label'):
                self._action_feedback_label.config(text="", bootstyle=DEFAULT)
            return
        self._search_after_id = self.after(self.SEARCH_DEBOUNCE_DELAY, self._perform_actual_search)

    def _perform_actual_search(self):
        self._search_after_id = None
        if not hasattr(self, '_eligible_students_tree') or not hasattr(self, '_action_feedback_label') or not hasattr(self, '_session_manager'):
            return
        search_term = self._search_entry_var.get()
        if len(search_term) < 2:
            self._action_feedback_label.config(text="")
            return

        logger.debug(f"Debounced search: {search_term}")
        eligible = self._session_manager.get_eligible_students()
        if eligible is None:
            logger.error("Eligible list unavailable.")
            self._action_feedback_label.config(text="Error", bootstyle=DANGER)
            return
        served = self._session_manager.get_served_pronts()
        matches = self._perform_fuzzy_search(search_term, eligible, served)
        self._update_eligible_treeview(matches)

        if matches:
            self._action_feedback_label.config(text=f"{len(matches)} match(es)", bootstyle=INFO)
            try:  # Auto-select first
                if self._eligible_students_tree.get_children_iids():
                    first_iid = self._eligible_students_tree.get_children_iids()[0]
                    self._eligible_students_tree.view.focus(first_iid)
                    self._eligible_students_tree.view.selection_set(first_iid)
            except Exception as e:
                logger.error(f"Error auto-selecting: {e}")
        else:
            self._action_feedback_label.config(text="No matches found", bootstyle=WARNING)

    def _perform_fuzzy_search(self, search_term: str, eligible_students: List[Dict[str, Any]], served_pronts: Set[str]) -> List[Dict[str, Any]]:
        # ... (Implementation unchanged from previous answer) ...
        term_lower = search_term.lower().strip()
        matches = []
        is_pront_search = bool(re.fullmatch(r'[\dx\s]+', term_lower))
        search_key = 'Pront' if is_pront_search else 'Nome'
        cleaned_search_term = PRONTUARIO_CLEANUP_REGEX.sub('', term_lower) if is_pront_search else term_lower
        match_func = fuzz.partial_ratio
        threshold = 85 if is_pront_search else 70
        for student in eligible_students:
            pront = student.get('Pront')
            if pront in served_pronts:
                continue
            value_to_match = student.get(search_key, '').lower()
            if is_pront_search:
                value_to_match = PRONTUARIO_CLEANUP_REGEX.sub('', value_to_match)
            score = match_func(cleaned_search_term, value_to_match) if search_term!='---' else 100
            if score >= threshold:
                student_copy = student.copy()
                display_turma = (student.get('Turma', '')[
                                 :20] + '...') if len(student.get('Turma', '')) > 20 else student.get('Turma', '')
                student_copy['info'] = f"{display_turma} | {PRONTUARIO_CLEANUP_REGEX.sub('', pront or '')}"
                student_copy['score'] = score
                matches.append(student_copy)
        matches.sort(key=lambda x: x['score'], reverse=True)
        return matches

    def _update_eligible_treeview(self, matches: List[Dict[str, Any]]):
        if not self._eligible_students_tree:
            return
        self._eligible_students_tree.delete_rows()
        self._current_eligible_matches_data = matches
        if not matches:
            return
        rowdata = [(m.get('Nome', 'N/A'), m.get('info', 'N/A'), m.get('Prato', 'N/A')) for m in matches]
        try:
            self._eligible_students_tree.build_table_data(self._eligible_students_tree.coldata, rowdata)
        except Exception as e:
            logger.exception("Error building eligible table.")
            messagebox.showerror("UI Error", "Could not display results.", parent=self)

    def _on_eligible_student_select(self, event=None):
        """ Handles selection change in the eligible students SimpleTreeView. """
        sel_label = getattr(self, '_selected_student_label', None)
        reg_button = getattr(self, '_register_button', None)
        act_label = getattr(self, '_action_feedback_label', None)
        if not self._eligible_students_tree or not sel_label or not reg_button or not act_label:
            return

        selected_iid = self._eligible_students_tree.get_selected_iid()
        if selected_iid:
            try:
                all_iids = self._eligible_students_tree.get_children_iids()
                selected_row_index = all_iids.index(selected_iid)
                if hasattr(self, '_current_eligible_matches_data') and selected_row_index < len(self._current_eligible_matches_data):
                    self._selected_eligible_data = self._current_eligible_matches_data[selected_row_index]
                    pront = self._selected_eligible_data.get('Pront', '?')
                    nome = self._selected_eligible_data.get('Nome', '?')
                    turma = self._selected_eligible_data.get('Turma', '?')
                    prato = self._selected_eligible_data.get('Prato', '?')
                    sel_label.config(text=f"Pront: {pront}\nName: {nome}\nClass: {turma}\nDish: {prato}")
                    reg_button.config(state=NORMAL)
                    act_label.config(text=f"Selected: {pront}", bootstyle=INFO)
                else:
                    raise ValueError("Index mismatch")
            except (ValueError, IndexError, AttributeError, tk.TclError) as e:
                logger.error(f"Error mapping selection to data: {e}")
                self._selected_eligible_data = None
                sel_label.config(text="Error selecting data.")
                reg_button.config(state=DISABLED)
                act_label.config(text="Selection Error", bootstyle=DANGER)
        else:  # No selection
            self._selected_eligible_data = None
            sel_label.config(text="Select student from list.")
            reg_button.config(state=DISABLED)
            act_label.config(text="", bootstyle=DEFAULT)

    def _register_selected_eligible(self):
        """ Registers the student stored in _selected_eligible_data. """
        if not self._selected_eligible_data:
            messagebox.showwarning("No Student", "Select student first.", parent=self)
            return

        pront = self._selected_eligible_data.get('Pront')
        nome = self._selected_eligible_data.get('Nome', '?')
        turma = self._selected_eligible_data.get('Turma', '')
        prato = self._selected_eligible_data.get('Prato', '?')
        hora = datetime.now().strftime("%H:%M:%S")
        student_tuple = (pront, nome, turma, hora, prato)

        logger.info(f"Registering eligible: {pront} - {nome}")
        success = self._session_manager.record_consumption(student_tuple)
        feedback_label = getattr(self, '_action_feedback_label', None)

        if success:
            logger.info(f"Registered {pront} successfully.")
            self.load_registered_students_into_table()  # Refresh registered table
            self.update_info_display()
            if feedback_label:
                feedback_label.config(text=f"Registered: {pront}", bootstyle=SUCCESS)
            if hasattr(self, '_search_entry_var'):
                self._search_entry_var.set("")  # Clears search, triggers eligible refresh
        else:
            logger.warning(f"Failed register {pront}.")
            is_served = pront in self._session_manager.get_served_pronts()
            if is_served:
                messagebox.showwarning('Already Registered', f'{nome} ({pront})\nAlready registered.', parent=self)
                if feedback_label:
                    feedback_label.config(text=f"ALREADY REGISTERED: {pront}", bootstyle=WARNING)
                if hasattr(self, '_search_entry_var'):
                    self._search_entry_var.set("")
            else:
                messagebox.showerror('Reg Error', f'Could not register:\n{nome} ({pront})', parent=self)
                if feedback_label:
                    feedback_label.config(text=f"ERROR registering {pront}", bootstyle=DANGER)

        # Reset selection state
        self._selected_eligible_data = None
        if hasattr(self, '_selected_student_label'):
            self._selected_student_label.config(text="Select student...")
        if hasattr(self, '_register_button'):
            self._register_button.config(state=DISABLED)
        self.focus_search_entry()

    def focus_search_entry(self):
        search_entry = getattr(self, '_search_entry', None)
        if search_entry:
            try:
                search_entry.focus_set()
            except tk.TclError:
                logger.warning("Could not focus search (window closing?).")

    # --- Registered Table Actions ---
    def on_table_delete_key(self, event=None):
        """ Handles Delete key press on the registered students Treeview. """
        if not self._registered_students_table:
            return
        selected_iid = self._registered_students_table.get_selected_iid()
        if not selected_iid:
            return
        row_values = self._registered_students_table.get_row_values(selected_iid)
        if not row_values:
            logger.error(f"Cannot get values for selected iid {selected_iid}.")
            return
        self.on_delete_confirmed(row_values, selected_iid)

    def on_delete_confirmed(self, row_data: Tuple, iid_to_delete: Optional[str] = None):
        """ Logic to perform deletion after confirmation. """
        if len(row_data) < 2:
            logger.error(f"Invalid data for deletion: {row_data}")
            return
        pront, nome = row_data[0], row_data[1]
        if not messagebox.askyesno("Confirm", f"Remove registration for:\n{pront} - {nome}?", parent=self):
            logger.debug(f"Deletion of {pront} cancelled.")
            return

        logger.info(f"Deleting consumption for {pront}.")
        success = self._session_manager.delete_consumption(row_data)
        if success:
            logger.info(f"Consumption for {pront} deleted.")
            if iid_to_delete and self._registered_students_table:
                try:
                    self._registered_students_table.delete_rows([iid_to_delete])
                    self._remove_delete_button(iid_to_delete)
                    self._reorder_delete_buttons()
                except Exception as e:
                    logger.exception("Error removing row/button UI.")
                    self.load_registered_students_into_table()
            else:
                self.load_registered_students_into_table()  # Fallback reload
            self.update_info_display()
            self._refresh_ui_after_data_change()
        else:
            logger.error(f"Failed to delete consumption for {pront}.")
            messagebox.showerror("Delete Error", f"Could not remove registration for {nome}.", parent=self)

    # --- Other Actions ---
    def export_session_to_excel(self) -> bool:
        # (Implementation unchanged)
        logger.info("Export to Excel requested.")
        session_details = self._session_manager.get_session_info()
        if not session_details:
            messagebox.showwarning("No Session", "No active session.", parent=self)
            return False
        served_data = self._session_manager.get_served_students_details()
        if not served_data:
            messagebox.showwarning("Empty Session", "No students registered.", parent=self)
            return False
        _, date_str, meal_type_str, _ = session_details  # date_str is DD/MM/YYYY
        meal_display = capitalize(meal_type_str or "Unk")
        time_str = self._session_manager.get_time() or "??"
        try:
            file_path = export_to_excel(served_data, meal_display, date_str, time_str)  # Pass DD/MM/YYYY
            if file_path:
                logger.info(f"Exported: {file_path}")
                messagebox.showinfo("Success", f"Exported:\n{file_path}", parent=self)
                return True
            else:
                logger.error("Export fail")
                messagebox.showerror("Error", "Failed Excel export.", parent=self)
                return False
        except Exception as e:
            logger.exception("Export error")
            messagebox.showerror("Error", f"Export error:\n{e}", parent=self)
            return False

    def sync_session_with_spreadsheet(self) -> bool:
        # (Implementation unchanged)
        logger.info("Sync Served Data requested.")
        if not self._session_manager.get_session_info():
            messagebox.showwarning("No Session", "No active session.", parent=self)
            return False
        self.show_progress_bar(True, "Syncing Served Data with Google Sheet...")
        sync_thread = SpreadsheetThread(self._session_manager)
        sync_thread.start()
        self._monitor_sync_thread(sync_thread, "Sync Served Data")
        return True

    def export_and_end_session(self):
        # (Implementation unchanged)
        logger.info("'Export & End Session' requested.")
        if not self._session_manager.get_session_info():
            messagebox.showwarning("No Session", "No active session.", parent=self)
            return
        if not messagebox.askyesno("Confirm", "Export locally and end session?", icon='warning', parent=self):
            logger.info("End cancelled.")
            return
        logger.info("Step 1: Exporting locally...")
        if not self.export_session_to_excel():
            if not messagebox.askyesno("Fail", "Local export failed.\nEnd anyway?", icon='error', parent=self):
                logger.warning("End aborted.")
                return
            else:
                logger.warning("Proceeding end despite export fail.")
        logger.info("Step 2: Clearing state file...")
        if self._remove_session_state_file():
            logger.info("State cleared.")
        else:
            logger.error("Failed to clear state file.")
            messagebox.showerror("Error", "Could not clear state file.", parent=self)
        logger.info("Closing application.")
        self.on_close_app()

    def _remove_session_state_file(self) -> bool:
        # (Implementation unchanged)
        try:
            Path(SESSION_PATH).unlink(missing_ok=True)
            logger.info(f"Session state handled: {SESSION_PATH}")
            return True
        except Exception as e:
            logger.exception(f"Error handling state file: {e}")
            return False

    # --- App Lifecycle ---
    def on_close_app(self):
        logger.info("Closing application...")
        if self._search_after_id is not None:
            self.after_cancel(self._search_after_id)
            self._search_after_id = None
        if hasattr(self, '_session_manager') and self._session_manager:
            if self._session_manager.get_session_info():
                logger.debug("Saving session state.")
                self._session_manager.save_session_state()
            logger.debug("Closing resources.")
            self._session_manager.close_resources()
        logger.debug("Destroying window.")
        self.destroy()
        logger.info("Application closed.")

    def get_session(self) -> 'SessionManager':
        if not hasattr(self, '_session_manager') or self._session_manager is None:
            raise RuntimeError("SessionManager N/A.")
        return self._session_manager

# --- Application Entry Point ---


def main():
    """ Configures and runs the Meal Registration application. """
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    log_file = log_dir / "registro_app.log"
    log_fmt = '%(asctime)s - %(levelname)-8s - %(name)-25s - %(message)s'
    log_datefmt = '%Y-%m-%d %H:%M:%S'
    try:
        from logging.handlers import RotatingFileHandler
        file_h = RotatingFileHandler(log_file, maxBytes=10*1024*1024, backupCount=5, encoding='utf-8')
        stream_h = logging.StreamHandler(sys.stdout)
        logging.basicConfig(level=logging.INFO, format=log_fmt, datefmt=log_datefmt, handlers=[file_h, stream_h])
    except Exception as log_err:
        print(f"FATAL: Log setup error: {log_err}", file=sys.stderr)
        sys.exit(1)

    logger.info("="*30 + " APPLICATION START " + "="*30)
    # DPI Awareness
    if platform.system() == "Windows":
        try:
            ctypes.windll.shcore.SetProcessDpiAwareness(1)
            logger.info("DPI awareness set (shcore).")
        except Exception:
            try:
                ctypes.windll.user32.SetProcessDPIAware()
                logger.info("DPI awareness set (user32).")
            except Exception:
                logger.warning("Could not set DPI awareness.")
    # Config Files
    try:
        config_dir = Path("./config").resolve()
        config_dir.mkdir(parents=True, exist_ok=True)
        snacks_path = config_dir / SNACKS_JSON_PATH.name
        if not snacks_path.exists():
            with open(snacks_path, 'w', encoding='utf-8') as f:
                json.dump(["Lanche Padrão"], f, indent=2)
            logger.info(f"Default snacks file created: '{snacks_path}'.")
    except Exception as config_err:
        logger.exception("Config setup error")
        messagebox.showerror("Config Error", f"Failed setup: {config_err}")
        sys.exit(1)
    # Run App
    app = None
    try:
        logger.info("Creating RegistrationApp instance...")
        app = RegistrationApp()
        logger.info("Starting Tkinter main event loop...")
        app.mainloop()
        logger.info("Tkinter main event loop finished.")
    except Exception as app_err:
        logger.critical("Critical runtime error.", exc_info=True)
        try:
            messagebox.showerror("Fatal Error", f"Unexpected error:\n{app_err}")
        except Exception:
            print(f"FATAL ERROR: {app_err}", file=sys.stderr)
        if app and isinstance(app, tk.Tk):
            try:
                app.destroy()
            except Exception:
                pass
        sys.exit(1)
    finally:
        logger.info("="*30 + " APPLICATION END " + "="*30 + "\n")

# Uncomment to run directly
# if __name__ == "__main__":
#     main()
