# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------------
# File: registro/view/session_dialog.py (Di√°logo de Gerenciamento de Sess√£o - View)
# ----------------------------------------------------------------------------
# SPDX-License-Identifier: MIT
# Copyright (c) 2024-2025 Mateus G Pereira <mateus.pereira@ifsp.edu.br>
"""
Fornece um di√°logo modal para criar uma nova sess√£o de refei√ß√£o ou carregar
uma sess√£o existente. Permite tamb√©m sincronizar os dados de reservas mestre.
"""
import datetime as dt
import logging
import tkinter as tk
from pathlib import Path
from tkinter import messagebox
from typing import TYPE_CHECKING, Callable, Dict, List, Sequence, Set, Tuple, Union

import ttkbootstrap as ttk

# Importa√ß√µes locais
from registro.control.constants import (
    INTEGRATED_CLASSES,
    SNACKS_JSON_PATH,
    UI_TEXTS,
    NewSessionData,
)
from registro.control.sync_thread import SyncReserves  # Thread de sincroniza√ß√£o
from registro.control.utils import capitalize, load_json, save_json  # Utilit√°rios
from registro.model.tables import Session as SessionModel  # Modelo DB

# Type checking para evitar importa√ß√µes circulares
if TYPE_CHECKING:
    from registro.control.session_manage import SessionManager
    from registro.view.registration_app import RegistrationApp

logger = logging.getLogger(__name__)

# --- Fun√ß√µes Auxiliares de Cria√ß√£o de Widgets ---


def create_class_checkbox_section(
    master: tk.Widget, available_classes: List[str]
) -> tuple[List[Tuple[str, tk.BooleanVar, ttk.Checkbutton]], ttk.Labelframe]:
    """
    Cria a se√ß√£o do di√°logo com checkboxes para selecionar as turmas participantes.

    Args:
        master: O widget pai onde o Labelframe ser√° colocado.
        available_classes: Lista dos nomes das turmas dispon√≠veis.

    Returns:
        Uma tupla contendo:
        - Lista de tuplas: `(nome_turma, variavel_tk, widget_checkbutton)`.
        - O widget ttk.Labelframe criado.
    """
    group_frame = ttk.Labelframe(
        master,
        text=UI_TEXTS.get(
            "participating_classes_label", "üéüÔ∏è Selecione Turmas Participantes"
        ),
        padding=6,
    )
    num_cols = 3  # N√∫mero de colunas para os checkboxes
    group_frame.columnconfigure(tuple(range(num_cols)), weight=1)  # Colunas expans√≠veis
    if not available_classes:
        # Mensagem se n√£o houver turmas no banco
        ttk.Label(
            group_frame,
            text=UI_TEXTS.get(
                "no_classes_found_db", "Nenhuma turma encontrada no banco de dados."
            ),
        ).grid(column=0, row=0, columnspan=num_cols, pady=10)
        # Ajusta a configura√ß√£o de linha mesmo sem turmas
        group_frame.rowconfigure(0, weight=1)
        return [], group_frame  # Retorna lista vazia e o frame

    # Calcula o n√∫mero de linhas necess√°rio
    num_rows = (len(available_classes) + num_cols - 1) // num_cols
    group_frame.rowconfigure(
        tuple(range(num_rows or 1)), weight=1
    )  # Linhas expans√≠veis

    checkbox_data = []  # Armazena dados dos checkboxes criados
    # Cria um checkbox para cada turma dispon√≠vel
    for i, class_name in enumerate(available_classes):
        check_var = tk.BooleanVar(value=False)  # Estado inicial desmarcado
        check_btn = ttk.Checkbutton(
            group_frame,
            text=class_name,
            variable=check_var,
            bootstyle="success-round-toggle",  # Estilo visual # type: ignore
        )
        check_btn.grid(
            column=i % num_cols,  # Coluna baseada no √≠ndice
            row=i // num_cols,  # Linha baseada no √≠ndice
            sticky="news",  # Expande em todas as dire√ß√µes
            padx=10,
            pady=5,
        )
        checkbox_data.append((class_name, check_var, check_btn))

    return checkbox_data, group_frame


# --- Classe Principal do Di√°logo ---


class SessionDialog(tk.Toplevel):
    """
    Janela de di√°logo para selecionar/criar sess√£o e sincronizar reservas.
    """

    def __init__(
        self,
        title: str,
        callback: Callable[[Union[NewSessionData, int, None]], bool],
        parent_app: "RegistrationApp",
    ):
        """
        Inicializa o di√°logo de sess√£o.

        Args:
            title: O t√≠tulo da janela do di√°logo.
            callback: Fun√ß√£o a ser chamada ao clicar em OK. Recebe os dados da nova
                      sess√£o (dict), o ID da sess√£o existente (int), ou None se
                      cancelado. Retorna True se a opera√ß√£o foi bem-sucedida na
                      janela principal, False caso contr√°rio (mant√©m di√°logo aberto).
            parent_app: A inst√¢ncia da aplica√ß√£o principal (RegistrationApp).
        """
        super().__init__(parent_app)
        self.withdraw()  # Esconde inicialmente

        self.title(title)
        self.transient(parent_app)  # Define como filha da janela principal
        self.grab_set()  # Torna modal

        # Refer√™ncias importantes
        self._callback = callback
        self._parent_app = parent_app
        # Obt√©m o SessionManager da aplica√ß√£o pai
        self._session_manager: "SessionManager" = parent_app.session_manager
        # Armazena dados dos checkboxes de turma
        self._classes_checkbox_data: List[
            Tuple[str, tk.BooleanVar, ttk.Checkbutton]
        ] = []
        # Armazena o mapeamento display -> ID das sess√µes existentes
        self._sessions_map: Dict[str, int] = {}
        # Conjunto para armazenar op√ß√µes de lanche carregadas/salvas
        self._snack_options_set: Set[str] = set()

        # Define a√ß√£o para o bot√£o de fechar da janela
        self.protocol("WM_DELETE_WINDOW", self._on_closing)

        # --- Cria√ß√£o das Se√ß√µes do Di√°logo ---
        # 1. Nova Sess√£o
        self._new_session_frame = self._create_section_new_session()
        self._new_session_frame.grid(
            column=0, row=0, padx=10, pady=(10, 5), sticky="ew"
        )

        # 2. Sele√ß√£o de Turmas
        available_classes = self._fetch_available_classes()
        self._classes_checkbox_data, self._class_selection_frame = (
            create_class_checkbox_section(self, available_classes)  # type: ignore
        )
        self._class_selection_frame.grid(
            column=0, row=1, padx=10, pady=5, sticky="nsew"
        )
        self.rowconfigure(1, weight=1)  # Permite que esta se√ß√£o expanda verticalmente

        # 3. Bot√µes de A√ß√£o para Turmas
        self._create_section_class_buttons().grid(
            column=0, row=2, padx=10, pady=5, sticky="ew"
        )

        # 4. Edi√ß√£o/Sele√ß√£o de Sess√£o Existente
        self._edit_session_frame = self._create_section_edit_session()
        self._edit_session_frame.grid(column=0, row=3, padx=10, pady=5, sticky="ew")

        # 5. Bot√µes Principais (OK, Cancelar, Sincronizar)
        self._main_button_frame = self._create_section_main_buttons()
        self._main_button_frame.grid(
            column=0, row=4, padx=10, pady=(5, 10), sticky="ew"
        )

        # --- Finaliza√ß√£o ---
        self.update_idletasks()  # Calcula dimens√µes
        self._center_window()  # Centraliza
        self.resizable(False, True)  # N√£o redimension√°vel horizontalmente
        self.deiconify()  # Mostra a janela

    def _fetch_available_classes(self) -> List[str]:
        """Busca as turmas dispon√≠veis no banco de dados."""
        try:
            classes = sorted(
                # Usa set para garantir nomes √∫nicos
                set(
                    g.nome
                    for g in self._session_manager.turma_crud.read_all()
                    # Filtra nomes nulos, vazios ou 'Vazio' (legado?)
                    if g.nome and g.nome.strip() and g.nome.lower() != "vazio"
                )
            )
            return classes
        except Exception as e:
            logger.exception(
                "Erro ao buscar turmas dispon√≠veis no banco de dados. %s: %s",
                type(e).__name__,
                e,
            )
            messagebox.showerror(
                UI_TEXTS.get("database_error_title", "Erro de Banco de Dados"),
                UI_TEXTS.get(
                    "error_fetching_classes", "N√£o foi poss√≠vel buscar as turmas."
                ),
                parent=self,
            )
            return []  # Retorna lista vazia em caso de erro

    def _center_window(self):
        """Centraliza este di√°logo em rela√ß√£o √† janela pai."""
        self.update_idletasks()
        parent = self._parent_app
        parent_x, parent_y = parent.winfo_x(), parent.winfo_y()
        parent_w, parent_h = parent.winfo_width(), parent.winfo_height()
        dialog_w, dialog_h = self.winfo_width(), self.winfo_height()
        pos_x = parent_x + (parent_w // 2) - (dialog_w // 2)
        pos_y = parent_y + (parent_h // 2) - (dialog_h // 2)
        self.geometry(f"+{pos_x}+{pos_y}")

    def _on_closing(self):
        """Chamado quando o di√°logo √© fechado pelo bot√£o 'X' ou 'Cancelar'."""
        logger.info("Di√°logo de sess√£o fechado pelo usu√°rio.")
        self.grab_release()  # Libera modalidade
        self.destroy()  # Destroi a janela
        try:
            # Chama o callback com None para indicar cancelamento
            self._callback(None)
        except Exception as e:
            logger.exception("Erro no callback de fechamento do di√°logo: %s", e)

    def _create_section_new_session(self) -> ttk.Labelframe:
        """Cria o frame com os campos para definir uma nova sess√£o."""
        frame = ttk.Labelframe(
            self,
            text=UI_TEXTS.get("new_session_group_label", "‚ûï Detalhes da Nova Sess√£o"),
            padding=10,
        )
        # Configura colunas para expandir campos de entrada
        frame.columnconfigure(1, weight=1)
        frame.columnconfigure(3, weight=1)

        # Campo Hora
        ttk.Label(master=frame, text=UI_TEXTS.get("time_label", "‚è∞ Hor√°rio:")).grid(
            row=0, column=0, sticky="w", padx=(0, 5), pady=3
        )
        self._time_entry = ttk.Entry(frame, width=8)
        self._time_entry.insert(0, dt.datetime.now().strftime("%H:%M"))  # HH:MM
        self._time_entry.grid(row=0, column=1, sticky="w", padx=5, pady=3)

        # Campo Data
        ttk.Label(master=frame, text=UI_TEXTS.get("date_label", "üìÖ Data:")).grid(
            row=0, column=2, sticky="w", padx=(10, 5), pady=3
        )
        self._date_entry = ttk.DateEntry(
            frame,
            width=12,
            bootstyle="primary",
            dateformat="%d/%m/%Y",  # Formato de exibi√ß√£o na UI
            # firstweekday=0 # Opcional: Define segunda como in√≠cio da semana
            # startdate=dt.date.today() # Opcional: Data inicial
        )
        self._date_entry.grid(row=0, column=3, sticky="ew", padx=(0, 5), pady=3)

        # Campo Tipo de Refei√ß√£o
        ttk.Label(
            master=frame, text=UI_TEXTS.get("meal_type_label", "üçΩÔ∏è Refei√ß√£o:")
        ).grid(row=1, column=0, sticky="w", padx=(0, 5), pady=3)
        now_time = dt.datetime.now().time()
        # Define Almo√ßo como padr√£o entre 11:00 e 13:30
        is_lunch_time = dt.time(11, 00) <= now_time <= dt.time(13, 30)
        meal_options = [
            UI_TEXTS.get("meal_snack", "Lanche"),
            UI_TEXTS.get("meal_lunch", "Almo√ßo"),
        ]
        self._meal_combobox = ttk.Combobox(
            master=frame, values=meal_options, state="readonly", bootstyle="info"  # type: ignore
        )
        self._meal_combobox.current(1 if is_lunch_time else 0)  # Define sele√ß√£o inicial
        self._meal_combobox.grid(
            row=1, column=1, columnspan=3, sticky="ew", padx=5, pady=3
        )
        # Associa evento para habilitar/desabilitar campo de lanche espec√≠fico
        self._meal_combobox.bind("<<ComboboxSelected>>", self._on_select_meal)

        # Campo Lanche Espec√≠fico
        ttk.Label(
            master=frame,
            text=UI_TEXTS.get("specific_snack_label", "ü•™ Lanche Espec√≠fico:"),
        ).grid(row=2, column=0, sticky="w", padx=(0, 5), pady=3)
        self._snack_options_set, snack_display_list = self._load_snack_options()
        self._snack_combobox = ttk.Combobox(
            master=frame, values=snack_display_list, bootstyle="warning"  # type: ignore
        )
        # Habilita/desabilita baseado na sele√ß√£o inicial de refei√ß√£o
        self._snack_combobox.config(
            state=(
                "disabled"
                if self._meal_combobox.get() == UI_TEXTS.get("meal_lunch", "Almo√ßo")
                else "normal"
            )
        )
        # Define sele√ß√£o inicial se houver op√ß√µes v√°lidas
        if snack_display_list and "Error" not in snack_display_list[0]:
            self._snack_combobox.current(0)  # Seleciona o primeiro da lista
        self._snack_combobox.grid(
            row=2, column=1, columnspan=3, sticky="ew", padx=5, pady=3
        )

        return frame

    def _load_snack_options(self) -> Tuple[Set[str], List[str]]:
        """Carrega as op√ß√µes de lanche do arquivo JSON."""
        snacks_path = Path(SNACKS_JSON_PATH)
        default_options = [UI_TEXTS.get("default_snack_name", "Lanche Padr√£o")]
        try:
            # Usa utilit√°rio load_json
            snack_options = load_json(str(snacks_path))
            # Valida se o conte√∫do √© uma lista de strings
            if not isinstance(snack_options, list) or not all(
                (isinstance(s, str) for s in snack_options)
            ):
                logger.error(
                    "Conte√∫do inv√°lido em '%s'. Esperada lista de strings.", snacks_path
                )
                # Define mensagem de erro para exibi√ß√£o
                error_msg = f"Erro: Conte√∫do inv√°lido em {snacks_path.name}"
                return set(), [error_msg]
            # Se a lista estiver vazia no arquivo, usa o padr√£o
            if not snack_options:
                return set(default_options), default_options
            # Retorna o conjunto (para verifica√ß√£o r√°pida) e a lista ordenada (para display)
            return set(snack_options), sorted(snack_options)
        except FileNotFoundError:
            logger.warning(
                "Arquivo de op√ß√µes de lanche '%s' n√£o encontrado. Usando padr√£o e criando arquivo.",
                snacks_path,
            )
            # Cria o arquivo com a op√ß√£o padr√£o se n√£o existir
            save_json(str(snacks_path), default_options)
            return set(default_options), default_options
        except Exception as e:
            logger.exception(
                "Erro ao carregar op√ß√µes de lanche de '%s'. %s: %s",
                snacks_path,
                type(e).__name__,
                e,
            )
            return (set(), [f"Erro ao carregar {snacks_path.name}"])

    def _create_section_class_buttons(self) -> ttk.Frame:
        """Cria o frame com bot√µes de a√ß√£o para sele√ß√£o de turmas."""
        button_frame = ttk.Frame(self)
        button_frame.columnconfigure(tuple(range(4)), weight=1)  # 4 colunas expans√≠veis
        # Configura√ß√£o dos bot√µes: (Texto da UI, Comando, Estilo)
        buttons_config = [
            ("clear_all_button", self._on_clear_classes, "outline-secondary"),
            ("select_integrated_button", self._on_select_integral, "outline-info"),
            ("select_others_button", self._on_select_others, "outline-info"),
            ("invert_selection_button", self._on_invert_classes, "outline-secondary"),
        ]
        for i, (text_key, cmd, style) in enumerate(buttons_config):
            ttk.Button(
                master=button_frame,
                text=UI_TEXTS.get(text_key, f"BTN_{i}"),  # Usa chave ou fallback
                command=cmd,
                bootstyle=style,  # type: ignore
                width=15,  # Largura fixa para alinhamento
            ).grid(row=0, column=i, padx=2, pady=2, sticky="ew")
        return button_frame

    def _create_section_edit_session(self) -> ttk.Labelframe:
        """Cria o frame para selecionar uma sess√£o existente."""
        frame = ttk.Labelframe(
            self,
            text=UI_TEXTS.get(
                "edit_session_group_label", "üìù Selecionar Sess√£o Existente para Editar"
            ),
            padding=10,
        )
        frame.columnconfigure(0, weight=1)  # Combobox expande horizontalmente

        # Carrega as sess√µes existentes do banco
        self._sessions_map, session_display_list = self._load_existing_sessions()

        # Cria o Combobox para exibir as sess√µes
        self._sessions_combobox = ttk.Combobox(
            master=frame,
            values=session_display_list,
            state="readonly",  # Impede digita√ß√£o
            bootstyle="dark",  # type: ignore
        )
        # Define o texto placeholder ou a primeira op√ß√£o
        placeholder = UI_TEXTS.get(
            "edit_session_placeholder",
            "Selecione uma sess√£o existente para carregar...",
        )
        if session_display_list and "Error" not in session_display_list[0]:
            self._sessions_combobox.set(placeholder)  # Define placeholder
        elif session_display_list:  # Caso de erro ao carregar
            self._sessions_combobox.current(0)  # Mostra a mensagem de erro
            self._sessions_combobox.config(state="disabled")
        else:  # Nenhuma sess√£o encontrada
            self._sessions_combobox.set(
                UI_TEXTS.get(
                    "no_existing_sessions", "Nenhuma sess√£o existente encontrada."
                )
            )
            self._sessions_combobox.config(state="disabled")

        self._sessions_combobox.grid(row=0, column=0, sticky="ew", padx=3, pady=3)
        return frame

    def _load_existing_sessions(self) -> Tuple[Dict[str, int], List[str]]:
        """Carrega sess√µes existentes do banco de dados para o combobox."""
        try:
            # Busca sess√µes ordenadas por data e hora (mais recentes primeiro)
            sessions: Sequence[SessionModel] = (
                self._session_manager.session_crud.read_all_ordered_by(
                    SessionModel.data.desc(), SessionModel.hora.desc()
                )
            )
            # Cria o mapa: "DD/MM/YYYY HH:MM - Refei√ß√£o (ID: id)" -> id
            sessions_map = {}
            for s in sessions:
                # Formata a data para exibi√ß√£o DD/MM/YYYY
                try:
                    display_date = dt.datetime.strptime(s.data, "%Y-%m-%d").strftime(
                        "%d/%m/%Y"
                    )
                except ValueError:
                    display_date = (
                        s.data
                    )  # Usa o formato original se a convers√£o falhar
                # Monta a string de exibi√ß√£o
                display_text = (
                    f"{display_date} {s.hora} - "
                    f"{capitalize(s.refeicao)} (ID: {s.id})"
                )
                sessions_map[display_text] = s.id

            return sessions_map, list(
                sessions_map.keys()
            )  # Retorna mapa e lista de chaves (display texts)
        except Exception as e:
            logger.exception(
                "Erro ao buscar sess√µes existentes do banco de dados. %s: %s",
                type(e).__name__,
                e,
            )
            error_msg = UI_TEXTS.get(
                "error_loading_sessions", "Erro ao carregar sess√µes"
            )
            return {error_msg: -1}, [error_msg]  # Retorna indicando erro

    def _create_section_main_buttons(self) -> ttk.Frame:
        """Cria o frame com os bot√µes principais: OK, Cancelar, Sincronizar."""
        button_frame = ttk.Frame(self)
        # Configura colunas para espa√ßamento e centraliza√ß√£o
        button_frame.columnconfigure(0, weight=1)  # Espa√ßo √† esquerda
        button_frame.columnconfigure(4, weight=1)  # Espa√ßo √† direita

        # Bot√£o Sincronizar Reservas
        ttk.Button(
            master=button_frame,
            text=UI_TEXTS.get("sync_reservations_button", "üì• Sincronizar Reservas"),
            command=self._on_sync_reserves,
            bootstyle="outline-warning",  # type: ignore
        ).grid(
            row=0, column=1, padx=5, pady=5
        )  # Coluna 1

        # Bot√£o Cancelar
        ttk.Button(
            master=button_frame,
            text=UI_TEXTS.get("cancel_button", "‚ùå Cancelar"),
            command=self._on_closing,  # Reutiliza a fun√ß√£o de fechar
            bootstyle="danger",  # type: ignore
        ).grid(
            row=0, column=2, padx=5, pady=5
        )  # Coluna 2

        # Bot√£o OK
        ttk.Button(
            master=button_frame,
            text=UI_TEXTS.get("ok_button", "‚úîÔ∏è OK"),
            command=self._on_okay,
            bootstyle="success",  # type: ignore
        ).grid(
            row=0, column=3, padx=5, pady=5
        )  # Coluna 3

        return button_frame

    # --- Handlers de Eventos e A√ß√µes ---

    def _on_select_meal(self, _=None):
        """Habilita/desabilita campo de lanche espec√≠fico ao mudar tipo de refei√ß√£o."""
        is_lunch = self._meal_combobox.get() == UI_TEXTS.get("meal_lunch", "Almo√ßo")
        new_state = "disabled" if is_lunch else "normal"
        self._snack_combobox.config(state=new_state)
        # Limpa o campo se for almo√ßo
        if is_lunch:
            self._snack_combobox.set("")

    def _on_clear_classes(self):
        """Desmarca todos os checkboxes de turma."""
        self._set_class_checkboxes(lambda name, var: False)

    def _on_select_integral(self):
        """Marca apenas os checkboxes das turmas integrais."""
        self._set_class_checkboxes(lambda name, var: name in INTEGRATED_CLASSES)

    def _on_select_others(self):
        """Marca apenas os checkboxes das turmas n√£o integrais."""
        self._set_class_checkboxes(lambda name, var: name not in INTEGRATED_CLASSES)

    def _on_invert_classes(self):
        """Inverte o estado de marca√ß√£o de todos os checkboxes de turma."""
        self._set_class_checkboxes(lambda name, var: not var.get())

    def _set_class_checkboxes(
        self, condition_func: Callable[[str, tk.BooleanVar], bool]
    ):
        """
        Aplica uma condi√ß√£o para marcar/desmarcar os checkboxes de turma.

        Args:
            condition_func: Fun√ß√£o que recebe (nome_turma, var_tk) e retorna
                            True para marcar, False para desmarcar.
        """
        if not self._classes_checkbox_data:  # Verifica se a lista existe
            logger.warning(
                "Tentativa de definir checkboxes de turma,"
                " mas a lista de dados n√£o est√° dispon√≠vel."
            )
            return
        for class_name, check_var, _ in self._classes_checkbox_data:
            check_var.set(condition_func(class_name, check_var))

    def _validate_new_session_input(self) -> bool:
        """Valida os campos de entrada para cria√ß√£o de uma nova sess√£o."""
        # Valida Hora
        try:
            dt.datetime.strptime(self._time_entry.get(), "%H:%M")
        except ValueError:
            messagebox.showwarning(
                UI_TEXTS.get("invalid_input_title", "Entrada Inv√°lida"),
                UI_TEXTS.get(
                    "invalid_time_format", "Formato de hora inv√°lido. Use HH:MM."
                ),
                parent=self,
            )
            self._time_entry.focus_set()  # Foca no campo inv√°lido
            return False

        # Valida Data (formato DD/MM/YYYY da UI)
        try:
            date_str = self._date_entry.entry.get()
            # Valida o formato DD/MM/YYYY que o usu√°rio v√™
            dt.datetime.strptime(date_str, "%d/%m/%Y")
        except ValueError:
            messagebox.showwarning(
                UI_TEXTS.get("invalid_input_title", "Entrada Inv√°lida"),
                UI_TEXTS.get(
                    "invalid_date_format",
                    "Formato de data inv√°lido. Use {date_format}.",
                ).format(date_format="DD/MM/YYYY"),
                parent=self,
            )
            self._date_entry.focus_set()  # Foca no campo
            return False
        except AttributeError:
            # Se n√£o conseguir acessar o widget interno do DateEntry (pouco prov√°vel)
            logger.warning(
                "N√£o foi poss√≠vel acessar o widget interno de DateEntry para valida√ß√£o."
            )
            # Pode permitir continuar ou retornar False, dependendo da criticidade

        # Valida Tipo de Refei√ß√£o
        valid_meals = [
            UI_TEXTS.get("meal_snack", "Lanche"),
            UI_TEXTS.get("meal_lunch", "Almo√ßo"),
        ]
        if self._meal_combobox.get() not in valid_meals:
            messagebox.showwarning(
                UI_TEXTS.get("invalid_input_title", "Entrada Inv√°lida"),
                UI_TEXTS.get(
                    "select_meal_type", "Selecione um Tipo de Refei√ß√£o v√°lido."
                ),
                parent=self,
            )
            return False

        # Valida Lanche Espec√≠fico (se for lanche)
        meal_type = self._meal_combobox.get()
        snack_selection = self._snack_combobox.get().strip()
        if meal_type == UI_TEXTS.get("meal_snack", "Lanche") and not snack_selection:
            messagebox.showwarning(
                UI_TEXTS.get("invalid_input_title", "Entrada Inv√°lida"),
                UI_TEXTS.get(
                    "specify_snack_name", "Especifique o nome do lanche para 'Lanche'."
                ),
                parent=self,
            )
            self._snack_combobox.focus_set()
            return False

        # Valida Sele√ß√£o de Turmas
        if not any(var.get() for _, var, _ in self._classes_checkbox_data):
            messagebox.showwarning(
                UI_TEXTS.get("invalid_selection_title", "Sele√ß√£o Inv√°lida"),
                UI_TEXTS.get(
                    "select_one_class", "Selecione pelo menos uma turma participante."
                ),
                parent=self,
            )
            return False

        # Todas as valida√ß√µes passaram
        return True

    def _save_new_snack_option(self, snack_selection: str):
        """Salva uma nova op√ß√£o de lanche no arquivo JSON se ela for nova."""
        # Verifica se a op√ß√£o √© nova, n√£o vazia e n√£o uma mensagem de erro
        if (
            snack_selection
            and snack_selection not in self._snack_options_set
            and "Error" not in snack_selection
        ):
            # Aplica capitaliza√ß√£o padr√£o
            normalized_snack = capitalize(snack_selection)
            logger.info(
                "Nova op√ß√£o de lanche digitada: '%s'. Adicionando √† lista.",
                normalized_snack,
            )
            self._snack_options_set.add(
                normalized_snack
            )  # Adiciona ao conjunto em mem√≥ria
            snacks_path = Path(SNACKS_JSON_PATH)
            try:
                # Tenta salvar a lista atualizada (ordenada) no JSON
                if save_json(str(snacks_path), sorted(list(self._snack_options_set))):
                    logger.info(
                        "Op√ß√µes de lanche atualizadas e salvas em '%s'.", snacks_path
                    )
                    # Atualiza as op√ß√µes no combobox
                    self._snack_combobox["values"] = sorted(
                        list(self._snack_options_set)
                    )
                    # Define a op√ß√£o rec√©m-adicionada como selecionada
                    self._snack_combobox.set(normalized_snack)
                else:
                    # save_json falhou (erro j√° logado)
                    messagebox.showerror(
                        UI_TEXTS.get("save_error_title", "Erro ao Salvar"),
                        UI_TEXTS.get(
                            "new_snack_save_error",
                            "N√£o foi poss√≠vel salvar a nova op√ß√£o de lanche.",
                        ),
                        parent=self,
                    )
            except Exception as e:
                logger.exception(
                    "Erro ao salvar nova op√ß√£o de lanche '%s' em '%s'. %s: %s",
                    normalized_snack,
                    snacks_path,
                    type(e).__name__,
                    e,
                )
                messagebox.showerror(
                    UI_TEXTS.get("save_error_title", "Erro ao Salvar"),
                    UI_TEXTS.get(
                        "unexpected_snack_save_error",
                        "Erro inesperado ao salvar lista de lanches.",
                    ),
                    parent=self,
                )

    def _on_okay(self):
        """A√ß√£o executada ao clicar no bot√£o OK. Tenta carregar ou criar sess√£o."""
        selected_session_display = self._sessions_combobox.get()
        session_id_to_load = None

        # Verifica se uma sess√£o existente foi selecionada (e n√£o √© placeholder/erro)
        is_placeholder = any(
            ph in selected_session_display for ph in ["Selecione", "Error", "Nenhuma"]
        )
        if selected_session_display and not is_placeholder:
            session_id_to_load = self._sessions_map.get(selected_session_display)

        if session_id_to_load is not None:
            # --- Carregar Sess√£o Existente ---
            logger.info(
                "Bot√£o OK: Requisitando carregamento da sess√£o existente ID %s",
                session_id_to_load,
            )
            # Chama o callback da janela principal para carregar a sess√£o
            success = self._callback(session_id_to_load)
            if success:
                logger.info(
                    "Sess√£o existente carregada com sucesso pela aplica√ß√£o principal."
                )
                self.grab_release()
                self.destroy()  # Fecha o di√°logo
            else:
                # Callback retornou False (ex: erro ao carregar no SessionManager)
                logger.warning(
                    "Aplica√ß√£o principal indicou falha ao carregar sess√£o existente."
                    " Di√°logo permanece aberto."
                )
                # Opcional: Mostrar mensagem de erro espec√≠fica? (depende do callback)
        else:
            # --- Criar Nova Sess√£o ---
            logger.info("Bot√£o OK: Tentando criar uma nova sess√£o.")
            # Valida os campos de entrada
            if not self._validate_new_session_input():
                return  # Interrompe se a valida√ß√£o falhar

            # Coleta os dados validados
            selected_classes = [
                txt for txt, var, _ in self._classes_checkbox_data if var.get()
            ]
            meal_type = self._meal_combobox.get()
            # Obt√©m nome do lanche (e salva se for novo)
            snack_selection = (
                self._snack_combobox.get().strip()
                if meal_type == UI_TEXTS.get("meal_snack", "Lanche")
                else None
            )
            if meal_type == UI_TEXTS.get("meal_snack", "Lanche") and snack_selection:
                self._save_new_snack_option(snack_selection)
                # Usa o valor possivelmente capitalizado pela fun√ß√£o _save_new_snack_option
                snack_selection = self._snack_combobox.get().strip()

            # Obt√©m a data do DateEntry e converte para YYYY-MM-DD para o backend
            try:
                date_ui = self._date_entry.entry.get()
                date_backend = dt.datetime.strptime(date_ui, "%d/%m/%Y").strftime(
                    "%Y-%m-%d"
                )
            except (ValueError, AttributeError) as e:
                logger.error(
                    "Erro ao converter data da UI (%s) para formato backend: %s",
                    date_ui,
                    e,
                )
                messagebox.showerror(
                    "Erro Interno",
                    "N√£o foi poss√≠vel processar a data selecionada.",
                    parent=self,
                )
                return

            # Monta o dicion√°rio NewSessionData
            new_session_data: NewSessionData = {
                "refei√ß√£o": meal_type,  # type: ignore # J√° est√° no formato esperado (Lanche/Almo√ßo)
                "lanche": snack_selection,
                "per√≠odo": "",  # Campo per√≠odo n√£o est√° na UI atual
                "data": date_backend,  # Formato YYYY-MM-DD
                "hora": self._time_entry.get(),  # Formato HH:MM
                "groups": selected_classes,  # Lista de nomes de turma
            }

            # Chama o callback da janela principal para criar a sess√£o
            success = self._callback(new_session_data)
            if success:
                logger.info("Nova sess√£o criada com sucesso pela aplica√ß√£o principal.")
                self.grab_release()
                self.destroy()  # Fecha o di√°logo
            else:
                # Callback retornou False (ex: erro ao criar no SessionManager)
                logger.warning(
                    "Aplica√ß√£o principal indicou falha ao criar nova sess√£o."
                    " Di√°logo permanece aberto."
                )
                # Opcional: Mostrar mensagem de erro espec√≠fica?

    def _on_sync_reserves(self):
        """Inicia a thread para sincronizar reservas mestre."""
        logger.info(
            "Bot√£o Sincronizar Reservas clicado. Iniciando thread de sincroniza√ß√£o."
        )
        # Mostra a barra de progresso na janela principal
        self._parent_app.show_progress_bar(
            True,
            UI_TEXTS.get("status_syncing_reservations", "Sincronizando reservas..."),
        )
        self.update_idletasks()  # Atualiza a UI antes de iniciar a thread

        # Cria e inicia a thread
        sync_thread = SyncReserves(self._session_manager)
        sync_thread.start()

        # Inicia o monitoramento da thread
        self._sync_monitor(sync_thread)

    def _sync_monitor(self, thread: SyncReserves):
        """Verifica o estado da thread de sincroniza√ß√£o periodicamente."""
        if thread.is_alive():
            # Se a thread ainda est√° rodando, agenda nova verifica√ß√£o
            self.after(150, lambda: self._sync_monitor(thread))
        else:
            # Thread terminou: esconde a barra de progresso
            self._parent_app.show_progress_bar(False)
            # Verifica o resultado
            if thread.error:
                logger.error("Sincroniza√ß√£o de reservas falhou: %s", thread.error)
                messagebox.showerror(
                    UI_TEXTS.get("sync_error_title", "Erro de Sincroniza√ß√£o"),
                    UI_TEXTS.get(
                        "sync_reserves_error_message",
                        "Falha ao sincronizar reservas:\n{error}",
                    ).format(error=thread.error),
                    parent=self,
                )
            elif thread.success:
                logger.info("Sincroniza√ß√£o de reservas conclu√≠da com sucesso.")
                messagebox.showinfo(
                    UI_TEXTS.get("sync_complete_title", "Sincroniza√ß√£o Conclu√≠da"),
                    UI_TEXTS.get(
                        "sync_reserves_complete_message",
                        "Reservas sincronizadas com sucesso com o banco de dados.",
                    ),
                    parent=self,
                )
                # Atualiza o combobox de sess√µes existentes, pois a sincroniza√ß√£o
                #   pode ter afetado dados
                self._update_existing_sessions_combobox()
            else:
                # Caso raro: thread terminou sem sucesso e sem erro expl√≠cito
                logger.warning(
                    "Thread de sincroniza√ß√£o de reservas finalizou com estado indeterminado."
                )
                messagebox.showwarning(
                    UI_TEXTS.get(
                        "sync_status_unknown_title",
                        "Status da Sincroniza√ß√£o Desconhecido",
                    ),
                    UI_TEXTS.get(
                        "sync_reserves_unknown_message",
                        "Sincroniza√ß√£o finalizada, mas status incerto.",
                    ),
                    parent=self,
                )

    def _update_existing_sessions_combobox(self):
        """Atualiza o conte√∫do do combobox de sess√µes existentes."""
        logger.debug("Atualizando combobox de sess√µes existentes...")
        # Recarrega os dados
        self._sessions_map, session_display_list = self._load_existing_sessions()
        # Atualiza os valores no widget
        self._sessions_combobox["values"] = session_display_list
        # Redefine o placeholder e estado
        placeholder = UI_TEXTS.get(
            "edit_session_placeholder",
            "Selecione uma sess√£o existente para carregar...",
        )
        if session_display_list and "Error" not in session_display_list[0]:
            self._sessions_combobox.set(placeholder)
            self._sessions_combobox.config(state="readonly")
        elif session_display_list:  # Caso de erro
            self._sessions_combobox.current(0)
            self._sessions_combobox.config(state="disabled")
        else:  # Lista vazia
            self._sessions_combobox.set(
                UI_TEXTS.get(
                    "no_existing_sessions", "Nenhuma sess√£o existente encontrada."
                )
            )
            self._sessions_combobox.config(state="disabled")
